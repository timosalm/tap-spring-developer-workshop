```terminal:interrupt
autostart: true
hidden: true
```

The API-first approach prioritizes the design and development of the application programming interface (API) before any other aspects of the application. 
This approach enables the consumers of an API to work more independently from its provider, and providers are able to facilitate discussions with stakeholders well before they might have coded themselves past the point of no return.

###### Discover API Documentation And More In Tanzu Developer Portal

Tanzu Developer Portal helps you to find documentation for APIs available in your organization and try them out before integrating them in your applications.

A core feature of Tanzu Developer Portal is the **Software Catalog**. The Software Catalog is a centralized system that keeps track of metadata for all the applications in your organization's ecosystem. The catalog is built around the concept of metadata YAML files stored together with the code, which are then harvested and visualized.
Here is an example of the YAML file from the product service.
```dashboard:reload-dashboard
name: GIT UI
url: {{ ingress_protocol }}://git-ui-{{ session_name }}.{{ ingress_domain }}?p=product-service.git;a=blob;f=catalog/component.yaml;hb=refs/heads/main
```
Let's open the Software Catalog.

```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/catalog
```

![Tanzu Developer Portal - Software Catalog](../images/dev-portal-catalog.png)

If you **switch the kind from "Component" to "System"** and select `sc-architecture-system` you can see lists of all the services, backing services, and also a graph visualizing their relationships.
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/catalog/default/system/sc-architecture-system
```
![Tanzu Developer Portal - Software Catalog](../images/dev-portal-system.png)
In addition to a link to jump to the related source code, there is also one to access the **technical documentation**, which can be written in Markdown format in a source-code repository and displayed alongside the relevant catalog entries.
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/docs/default/System/sc-architecture-system
```

APIs provided by the components can be  v. Navigate back to the system view by clicking on the action, and **click on the only item's name in the APIs section**. If you **then switch from the Overview to the Definition tab**, you get a swagger-like experience to discover APIs like in the picture below.
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/catalog/default/system/sc-architecture-system
```
![Tanzu Developer Portal - API documentation plug-in](../images/dev-portal-api.png)
With a feature called **API Auto Registration**, TAP can automatically register your APIs in Tanzu Developer Portal.

The configuration of the API Auto Registration requires an OpenAPI Specification (OAS), which can be autogenerated in Spring Boot applications with the [springdoc-openapi](https://springdoc.org) Java library.

We only have to add the library to our project's `pom.xml`, and no additional configuration is needed to expose the API documentation at the following path in JSON format: `/v3/api-docs`.
```editor:insert-lines-before-line
file: ~/product-service/pom.xml
line: 19
text: |2
      <springdoc.version>2.2.0</springdoc.version>
cascade: true
```
```editor:insert-lines-before-line
file: ~/product-service/pom.xml
line: 34
text: |2
      <dependency>
        <groupId>org.springdoc</groupId>
        <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
        <version>${springdoc.version}</version>
      </dependency>
```
As this library is not managed by the [standard BOM (Bills of Materials)](https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-dependencies/build.gradle) included in the `spring-boot-starter-parent` project, we have to specify a version.

After committing our code changes, we can configure the API Auto Registration in the Workload.
```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: metadata.labels
value:
  apis.apps.tanzu.vmware.com/register-api: "true"
cascade: true
```
```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec.params
value:
  - name: api_descriptor
    value:
      type: openapi
      location:
        path: "/v3/api-docs"
      system: sc-architecture-system
      owner: team-vmware-tanzu-se
      description: "An API to manage products within the Spring Cloud Architecture app."
```

Let's commit the updated source code and wait until our changes are deployed, and the new endpoint with the OAS is available.
```terminal:execute
command: |
  (cd product-service && git add . && git commit -m "Add OAuth support" && git push)
clear: true
cascade: true
```
```terminal:execute
command: watch -n 1 'curl -s https://product-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/v3/api-docs | jq .'
clear: true
session: 2
```

After that, it's time to apply the Workload and wait until the `APIDescriptor` is created, and in status `Ready`.
```terminal:execute
command: |
  kubectl apply -f ~/product-service/config/workload.yaml
clear: true
cascade: true
```
```terminal:interrupt
session: 2
hidden: true
cascade: true
```
```terminal:execute
command: watch kubectl get APIDescriptor product-service
clear: true
session: 2
```
```terminal:interrupt
session: 2
```

You should be now able to discover the newly registered API in the Tanzu Developer Portal.
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/api-docs?filters%5Bkind%5D=api&filters%5Buser%5D=all&filters%5Bowners%5D=group%3A{{ session_namespace }}%2Fteam-vmware-tanzu-se
```

###### Runtime Resources and App Live View
From the different components in the Software Catalog, you can also jump to the **Runtime Resources** view and have a closer look at the resources running on Kubernetes for your applications. Click the link below to see the workloads for the product service.
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/catalog/default/component/product-service/workloads
```

If you select a Pod, you're able to see the logs and information provided by **App Live View**.
![](../images/product-service-pod.png)
![](../images/pod-logs.png)
![](../images/app-live-view.png)

###### API Gateway

With so many APIs in a microservices application, developers need an API Gateway that they can control!

**VMware Spring Cloud Gateway for Kubernetes** is an **API gateway created for developers** based on the open-source [Spring Cloud Gateway](https://spring.io/projects/spring-cloud-gateway), along with integrating other Spring ecosystem projects such as Spring Security, Spring Session, and more. It automates the deployment of an API gateway service via the [Kubernetes Operator](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) pattern, and includes several other [commercial features](https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/2.0/scg-k8s/GUID-index.html#key-features) like simple Single Sign-On (SSO) configuration and OpenAPI version 3 documentation auto-generation.

![VMware Spring Cloud Gateway for Kubernetes](../images/scg-for-k8s.png)

Let's create an instance of Spring Cloud Gateway for our application.

First, we have to configure a gateway instance via the `SpringCloudGateway` Kubernetes custom resource.
```editor:append-lines-to-file
file: ~/config/gateway/gateway.yaml
description: Create SpringCloudGateway resource configuration
text: |
  apiVersion: "tanzu.vmware.com/v1"
  kind: SpringCloudGateway
  metadata:
    name: api-gateway-1
  spec:
    api:
      version: "1.0"
      groupId: sc-architecture-system
      serverUrl: https://gateway-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}
      cors:
        allowedOrigins:
        - "https://*.{{ ENV_TAP_INGRESS }}"
        allowedMethods:
        - '*'
        allowedHeaders:
        - '*'
    observability:
      tracing:
        zipkin:
          enabled: true
          url: http://zipkin:9411/api/v2/spans
    java-opts: "-Dmanagement.tracing.propagation.type=w3c -Dmanagement.tracing.sampling.probability=1.0 -Dspring.codec.max-in-memory-size=-1" # Required for a later applied response body filter
```

In the commercial version of Spring Cloud Gateway we define routes in a Kubernetes resource called `SpringCloudGatewayRouteConfig`. 

Those route configurations have to be linked to a gateway instance with a custom resource named `SpringCloudGatewayMapping` to be able to share them between different gateway instances.

In TAP 1.7 `API Curation` was introduced as a new feature to curate one or more Workload OpenAPI specifications into a single aggregated API.

Via a `CuratedAPIDescriptor` resource, you can reference a list of `APIDescriptors` and define how path-based routing aggregates them.

If you have a Spring Cloud Gateway instance, the API Auto Registration controller is even able to automatically create a `SpringCloudGatewayRouteConfig` and `SpringCloudGatewayMapping` for you.

Let's configure the `CuratedAPIDescriptor` for the services that expose a REST API. 
```editor:append-lines-to-file
file: ~/config/gateway/curated-api-descriptor.yaml
description: Create CuratedAPIDescriptor resource configuration
text: |
  apiVersion: apis.apps.tanzu.vmware.com/v1alpha1
  kind: CuratedAPIDescriptor
  metadata:
    name: gateway
    annotations:
      "apis.apps.tanzu.vmware.com/route-provider": "spring-cloud-gateway"
  spec:
    type: openapi
    title: Spring Cloud Architecture API
    description: A set of API endpoints to manage the resources within the Spring Cloud Architecture app.
    groupId: sc-architecture-system
    version: "1.0"
    system: sc-architecture-system
    owner: team-vmware-tanzu-se
    apiDescriptors:
      - name: order-service
        namespace: {{ session_namespace }}
        pathPrefix: /services/order-service
      - name: product-service
        namespace: {{ session_namespace }}
        pathPrefix: /services/product-service
```
The `groupId` and `version` have to match the values of your Spring Cloud Gateway instance.

We can now apply the two resources to the cluster to create the gateway, and API curation.
```terminal:execute
command: kubectl apply -f ~/config/gateway/
clear: true
```

Let's first have closer look at the auto-created `SpringCloudGatewayRouteConfig` and `SpringCloudGatewayMapping` resources.
```terminal:execute
command: kubectl eksporter SpringCloudGatewayRouteConfig
clear: true
```
```terminal:execute
command: kubectl eksporter SpringCloudGatewayMapping
clear: true
```

If we have a look at the status of the `CuratedAPIDescriptor`, we can see the URL, where the curated OpenAPI spec of our services is available.
```terminal:execute
command: kubectl get CuratedAPIDescriptor
clear: true
```

As this OpenAPI spec is not auto-registered in Tanzu Developer Portal, let's do this now, and view it afterward.
```editor:append-lines-to-file
file: ~/config/gateway/api-descriptor.yaml
description: Create APIDescriptor resource configuration for curated API spec
text: |
  apiVersion: apis.apps.tanzu.vmware.com/v1alpha1
  kind: APIDescriptor
  metadata:
    name: gateway
  spec:
    description: A set of API endpoints to manage the resources within the Spring Cloud Architecture app.
    location:
      apiSpec:
        url: https://api-auto-registration.{{ ENV_TAP_INGRESS }}
        path: /openapi/{{ session_namespace }}/gateway
      server:
        ref:
          apiVersion: projectcontour.io/v1
          kind: HTTPProxy
          name: api-gateway
    owner: team-vmware-tanzu-se
    system: sc-architecture-system
    type: openapi
```
```terminal:execute
command: kubectl apply -f ~/config/gateway/
clear: true
```
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/api-docs?filters%5Bkind%5D=api&filters%5Buser%5D=all&filters%5Bowners%5D=group%3A{{ session_namespace }}%2Fteam-vmware-tanzu-se
```

With the gateway as the single entry point to our application, we shouldn't need to expose the order and product service directly anymore. This can be done by setting the `networking.knative.dev/visibility: cluster-local` label on your Workloads. 

*Hint: Even if this also works with the default installation of TAP, for production, a second ingress controller has to be configured with service type ClusterIP and configured in Knative, so that the services are really not reachable from the outside.*

We can now validate whether our configuration works by sending a request through it to the order service. 
```terminal:execute
command: |
  curl -s -X POST -H "Content-Type: application/json" -d '{"productId":"1", "shippingAddress": "Stuttgart"}' https://gateway-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/services/order-service/api/v1/orders | jq .
clear: true
```
We can also use ZipKin UI to see the new request flow.
```dashboard:open-url
url: https://zipkin-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/?serviceName=api-gateway-1&annotationQuery=method%3DPOST&lookback=12h&endTs=1692042417857&limit=100
```

![Updated architecture with API Gateway](../images/microservice-architecture-gateway.png)
