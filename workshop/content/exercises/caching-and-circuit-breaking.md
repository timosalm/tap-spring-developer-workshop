```dashboard:open-dashboard
name: The Twelve Factors
```

The **fourth and sixth factor** implies that any **data** that needs to be persisted must be **stored in a stateful backing service**, such as a database because the processes are stateless and share-nothing.
A backing service is any service that your application needs for its functionality. Examples of the different types of backing services are data stores, messaging systems, and also services that provide business functionality.

Those backing services are handled as attached resources in a 12-factor app which can be swapped without changing the application code in case of failures.

##### Provisioning and consumption of backing services

TAP makes it easy as possible to discover, curate, consume, and manage backing services, such as databases, queues, and caches, across single or multi-cluster environments. 

This experience is made possible by using the **Services Toolkit** component. 

The **order service** uses a **PostgreSQL database** to store orders ...
```editor:open-file
file: ~/order-service/pom.xml
line: 34
```
```editor:open-file
file: ~/order-service/src/main/java/com/example/orderservice/order/OrderApplicationService.java
line: 32
```

... and **RabbitMQ** to asynchronously communicate with the **shipping service**.
```editor:open-file
file: ~/order-service/pom.xml
line: 43
```
```editor:open-file
file: ~/order-service/src/main/java/com/example/orderservice/order/ShippingService.java
line: 45
```

For the best experience, developers should have a self-service to provision backing services across all the stages for the application.

The Services Toolkit provides **dynamic provisioning** capabilities with **Crossplane**, and we are also **partnering with the company behind that open-source project called Upbound**.
Support for additional provisioners might be added in the future.

In this workshop, we will run commands manually to dynamically provision a backing services for our application - in production environments, this should be automated.

Let's first discover available service classes in the cluster. 
```terminal:execute
command: tanzu service class list
clear: true
```

There are several [Bitnami](https://bitnami.com) Helm charts for data services available, which are pre-installed with TAP as examples. Those services can run everywhere where Crossplane supports the provisioning, e.g. in a Kubernetes cluster or native on a public cloud.

The service classes abstraction and Crossplane make it also possible to have a different way of provisioning for e.g. a PostgreSQL database in different stage without changing the workload or resources generated by the supply chain for it. So a PostgreSQL database in test cluster could be dynamically provisioned as Helm Chart, and for production as a native AWS service. 

We can have a closer look at a service class to see available configuration options exposed by the platform operators.
```terminal:execute
command: tanzu service class get postgresql-unmanaged
clear: true
```
Now we can claim the pre-installed Bitnami PostgreSQL service to obtain such a database.
```terminal:execute
command: tanzu service class-claim create postgres-1 --class postgresql-unmanaged --parameter storageGB=1
clear: true
```
It might take a moment or two before the claim reports `Ready: True`. After the claim is ready, you then have a successful claim for a PostgreSQL database.
```terminal:execute
command: tanzu services class-claims get postgres-1
clear: true
```
Let's also trigger the provisioning of a RabbitMq instance.
```terminal:execute
command: tanzu service class-claim create rmq-1 --class rabbitmq-unmanaged --parameter storageGB=1
clear: true
```
Services Toolkit also provides the **functionality to automatically inject credentials that are required for the connection to the backing services** into the containers of the running application via the [Service Binding Specification](https://github.com/k8s-service-bindings/spec) for Kubernetes. 

The **developer defines the backing services** the application wants **to bind to in the Workload**. Those backing services have to be available in the cluster or registered in it to be consumed by the service binding.
```editor:insert-value-into-yaml
file: ~/order-service/config/workload.yaml
path: spec
value:
  serviceClaims:
  - name: db
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ClassClaim
      name: postgres-1
  - name: rmq
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ClassClaim
      name: rmq-1
```

After configuring the Workload definition for the service bindings on our machine, we have to update it on the cluster.
```terminal:execute
command: tanzu apps workload apply -f order-service/config/workload.yaml -y
clear: true
``` 

Let's see how we can make our application even more **resilient to backing service failures**.

##### Caching

Traditional databases, for example, are often too brittle or unreliable for use with microservices. That's why every modern distributed architecture needs a cache!
The [Spring Framework provides support for transparently adding caching](https://docs.spring.io/spring-framework/reference/integration/cache.html#page-title) to an application. 
The cache abstraction **does not provide an actual store**. Examples of Cache providers that are supported out of the box are **EhCache, Hazelcast, Couchbase, Redis and Caffeine**. Part of the VMware Tanzu portfolio is also an in-memory data grid called **VMware Tanzu Gemfire** that is powered by Apache Geode and can be used with minimal configuration.

To **improve the reliability and performance of our calls from the order service to its relational database via JDBC and the product service via REST**, let's add a distributed caching solution, in this case, **Redis**.
With Spring Boot's autoconfiguration, Caching abstraction, and in this case Spring Data Redis, it's very easy to add Caching to the **order-service**.

Let's first claim the pre-installed Bitnami Redis service to obtain an instance for the service ...
```terminal:execute
command: tanzu service class-claim create redis-1 --class redis-unmanaged --parameter storageGB=0.5
clear: true
```
... and add a service binding to our Workload.
```editor:insert-value-into-yaml
file: ~/order-service/config/workload.yaml
path: spec.serviceClaims
value:
  - name: cache
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ClassClaim
      name: redis-1
```

Next, the required libraries have to be added to our `pom.xml`.
```editor:insert-lines-before-line
file: ~/order-service/pom.xml
line: 68
text: |2
          <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
          </dependency>
          <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
          </dependency>
```

After adding required libraries to our `pom.xml`, caching, and related annotations have to be declaratively enabled via the `@EnableCaching` annotation on a @Configuration class or alternatively via XML configuration.
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/OrderServiceApplication.java
line: 10
text: |
    import org.springframework.cache.annotation.EnableCaching;
```
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/OrderServiceApplication.java
line: 12
text: |
    @EnableCaching
```

For the REST call to the product service, caching can be added to the related method with the `@Cacheable` annotation and a name for the associated cache.
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/order/ProductService.java
line: 13
text: |
    import org.springframework.cache.annotation.Cacheable;
```
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/order/ProductService.java
line: 30
text: |2
      @Cacheable("Products")
```

For caching of the calls to its relational database, we first have to override all the used methods of the JpaRepository to be able to add related annotations. 
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/order/OrderRepository.java
line: 8
text: |2
      @Cacheable("Orders")
      @Override
      List<Order> findAll();

      @Cacheable("Order")
      @Override
      Optional<Order> findById(Long id);

      @Override
      <S extends Order> S save(S order);
```
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/order/OrderRepository.java
line: 5
text: |
     import org.springframework.cache.annotation.Cacheable;
```

The cache abstraction not only allows populating caches but also allows removing the cached data with the `@CacheEvict`, which makes for example sense for the save method, that adds a new order to the database.
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/order/OrderRepository.java
line: 6
text: |
     import org.springframework.cache.annotation.CacheEvict;
```
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/order/OrderRepository.java
line: 18
text: |2
      @CacheEvict(cacheNames = {"Order", "Orders"}, allEntries = true)
```

To apply the changes, we have to update the Workload in the environment and commit the updated source code.
```terminal:execute
command: |
  cd order-service && git add . && git commit -m "Add caching" && git push
  cd ..
clear: true
```
```terminal:execute
command: tanzu apps workload apply -f order-service/config/workload.yaml -y
clear: true
```

As soon as our outdated application and service binding is applied ...
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/supply-chain/host/{{ session_namespace }}/order-service
```

... let's check whether the caching works via the application logs and sending two requests to the API.
```terminal:execute
command: curl https://order-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/orders
clear: true
```
```execute-2
kubectl logs -l serving.knative.dev/service=order-service -f
```
```terminal:execute
command: curl https://order-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/orders
clear: true
```

```terminal:interrupt
session: 2
```

![Updated architecture with Caching](../images/microservice-architecture-cache.png)

##### Circuit Breaker

In distributed systems like microservices, requests might time out or fail completely.
If for example the cache of the product list for our order service has expired and a request to the product service to fetch the product list fails, with a so-called Circuit Breaker, we are able to define a fallback that will be called for all further calls to the product service until a variable amount of time, to allow the product service to recover and prevent a network or service failure from cascading to other services.

[Spring Cloud Circuit Breaker](https://spring.io/projects/spring-cloud-circuitbreaker) supports the two open-source options Resilience4J, and Spring Retry. We'll now integrate Resilience4J in the order service.

First, we have to add the required library to our `pom.xml`.
```editor:insert-lines-before-line
file: ~/order-service/pom.xml
line: 76
text: |2
          <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
          </dependency>
```

To create a circuit breaker in your code, you can use the CircuitBreakerFactory.
```editor:select-matching-text
file: ~/order-service/src/main/java/com/example/orderservice/order/ProductService.java
text: "ProductService(RestTemplate restTemplate) {"
```
```editor:replace-text-selection
file: ~/order-service/src/main/java/com/example/orderservice/order/ProductService.java
text: |2
  private final CircuitBreakerFactory circuitBreakerFactory;
      ProductService(RestTemplate restTemplate, CircuitBreakerFactory circuitBreakerFactory) {
          this.circuitBreakerFactory = circuitBreakerFactory;
```

`CircuitBreakerFactory.create` will create a `CircuitBreaker` instance that provides a run method that accepts a `Supplier` and a `Function` as an argument. 
```editor:select-matching-text
file: ~/order-service/src/main/java/com/example/orderservice/order/ProductService.java
text: "return Arrays.asList(Objects.requireNonNull(restTemplate.getForObject(productsApiUrl, Product[].class)));"
```
```editor:replace-text-selection
file: ~/order-service/src/main/java/com/example/orderservice/order/ProductService.java
text: |2
  return circuitBreakerFactory.create("products").run(() ->
              Arrays.asList(Objects.requireNonNull(
                restTemplate.exchange(productsApiUrl, HttpMethod.GET, new HttpEntity<>(null, headers), Product[].class).getBody()
          )),
          throwable -> {
              log.error("Call to product service failed, using empty product list as fallback", throwable);
              return Collections.emptyList();
          });
```
```editor:insert-lines-before-line
file: ~/order-service/src/main/java/com/example/orderservice/order/ProductService.java
line: 14
text: |
    import java.util.Collections;
    import org.springframework.cloud.client.circuitbreaker.CircuitBreakerFactory;
```
The `Supplier` is the code that you are going to wrap in a circuit breaker. The `Function` is the fallback that will be executed if the circuit breaker is tripped. In our case, the fallback just returns an empty product list. The function will be passed the Throwable that caused the fallback to be triggered. You can optionally exclude the fallback if you do not want to provide one.

After pushing our changes to Git, the updated source code will be automatically deployed to production. 
```terminal:execute
command: |
  cd order-service && git add . && git commit -m "Add circuit-breaker" && git push
  cd ..
clear: true
```
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/supply-chain/host/{{ session_namespace }}/order-service
```

As soon as the updated application is running, we can test the functionality by terminating the product service, and sending a request to the order service. 
```execute-2
kubectl logs -l serving.knative.dev/service=order-service -f
```

```terminal:execute
command: kubectl delete app product-service
clear: true
```

```terminal:execute
command: |
  curl -X POST -H "Content-Type: application/json" -d '{"productId":"1", "shippingAddress": "Stuttgart"}' https://order-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/orders
clear: true
```
If everything works as expected the order service should fall back to an empty product list instead, and you should see the log entry `Call to product service failed, using empty product list as fallback`.

```terminal:interrupt
session: 2
```

![Updated architecture with Circuit Breaker](../images/microservice-architecture-cb.png)