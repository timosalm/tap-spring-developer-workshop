The **fourth and sixth factor** implies that any **data** that needs to be persisted must be **stored in a stateful backing service**, such as a database because the processes are stateless and share-nothing.
A backing service is any service that your application needs for its functionality. Examples of the different types of backing services are data stores, messaging systems, and also services that provide business functionality.

Those backing services are handled as attached resources in a 12-factor app which can be swapped without changing the application code in case of failures.

##### Provisioning and consumption of backing services

TAP makes it easy as possible to discover, curate, consume, and manage backing services, such as databases, queues, and caches, across single or multi-cluster environments. 

This experience is made possible by using the **Services Toolkit** component. 

To demonstrate how a Spring Boot app can use backing services on TAP lets use the order-service.

![Order Microservice](../images/microservice-architecture-cache.png)

To modify the order service to use services on TAP lets first import it into our IDE's workshpace.

Open the Explorer view in the IDE.

```editor:execute-command
command: workbench.view.explorer
```
The order service is in the following directory, copy the path to your clipboard

```copy
/home/eduk8s/order-service/
```

Now we need to add the order service to our workspace.  Execute the command below.

```editor:execute-command
command: workbench.action.addRootFolder
```

In the "Add Folder To Workspace" popup paste the path to the order service project and click OK.

![](../images/add-order-service-to-workspace.png)


The **order service** uses a **PostgreSQL database** to store orders.  We have both `spring-boot-starter-data-jpa` and `postgresql` on the classpath.
{% raw %}
```
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
```
{% endraw %}

The order service saves and updates orders to the database within the `OrderApplicationService` class.

```editor:open-file
file: ~/order-service/src/main/java/com/example/orderservice/order/OrderApplicationService.java
line: 32
```

The order service also uses and **RabbitMQ** to asynchronously communicate with the **shipping service** and includess `spring-boot-starter-amqp` on the classpath.
{% raw %}
```
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-amqp</artifactId>
		</dependency>
```
{% endraw %}

The order service sends messages to the shipping service within the `ShippingService` using the `exchange` method.

```editor:open-file
file: ~/order-service/src/main/java/com/example/orderservice/order/ShippingService.java
line: 45
```

TAP provides developers a self-service model to provision backing services across for their applications.

In this workshop, we will run commands manually to dynamically provision a backing services for our application - in production environments, this should be automated.

Let's first discover available service classes in the cluster. 
```terminal:execute
command: tanzu service class list
clear: true
```
There are several [Bitnami](https://bitnami.com) Helm charts for data services available, which are pre-installed with TAP as examples. Those services can run everywhere where Crossplane supports the provisioning, e.g. in a Kubernetes cluster or native on a public cloud.

The service classes abstraction and Crossplane make it also possible to have a different way of provisioning services in different environments without changing the workload or resources generated by the supply chain. So a PostgreSQL database in test cluster could be dynamically provisioned as Helm Chart while in a production environment you could use a native AWS service. 

We can have a closer look at a service class in TAP to see available configuration options exposed by the platform operators.

```terminal:execute
command: tanzu service class get postgresql-unmanaged
clear: true
```
This should result in a list that looks similar to 
{% raw %}
```
  NAME                  DESCRIPTION               
  kafka-unmanaged       Kafka by Bitnami          
  mongodb-unmanaged     MongoDB by Bitnami        
  mysql                 MySQL DB Instances        
  mysql-unmanaged       MySQL by Bitnami          
  postgresql-unmanaged  PostgreSQL by Bitnami     
  rabbitmq              It's a RabbitMQ cluster!  
  rabbitmq-unmanaged    RabbitMQ by Bitnami       
  redis-unmanaged       Redis by Bitnami
```
{% endraw %}

Since the order service needs a PostgreSQL database lets claim the pre-installed Bitnami PostgreSQL service to obtain such a database.
```terminal:execute
command: tanzu service class-claim create postgres-1 --class postgresql-unmanaged --parameter storageGB=1
clear: true
```
It might take a moment or two before the claim reports `Ready: True`. After the claim is ready, you then have a successful claim for a PostgreSQL database.
We can check whether the claim is ready by executing the following command.  The `status.Ready` value should be `True`.

```terminal:execute
command: tanzu services class-claims get postgres-1
clear: true
```
The order service also needs a RabbitMQ instance so lets go ahead and create a claim for that service as well.

```terminal:execute
command: tanzu service class-claim create rmq-1 --class rabbitmq-unmanaged --parameter storageGB=1
clear: true
```
Before moving on lets make sure the `status.Ready` value of the RabbitMQ service claim is `True`.

```terminal:execute
command: tanzu services class-claims get rmq-1
clear: true
```
Now that we have created service claims for the services we need we need to bind them to the order service workload (just like we bound the configuration service to the product service earlier).
When these services are bound to the workload TAP will automatically set the correct Spring Data and Spring AMQP configuration properties for the username, password, and server URL using the [Service Binding Specification](https://github.com/k8s-service-bindings/spec) for Kubernetes. 

Lets add the necessary service claims to the workload for the order service.

```editor:insert-value-into-yaml
file: ~/order-service/config/workload.yaml
path: spec.serviceClaims
value:
- name: db
  ref:
    apiVersion: services.apps.tanzu.vmware.com/v1alpha1
    kind: ClassClaim
    name: postgres-1
- name: rmq
  ref:
    apiVersion: services.apps.tanzu.vmware.com/v1alpha1
    kind: ClassClaim
    name: rmq-1
```

After configuring the Workload definition for the service bindings on our machine, we have to update it on the cluster.

```terminal:execute
command: tanzu apps workload apply -f order-service/config/workload.yaml -y
clear: true
```
We can track the rollout of the latest version of the order service by tailing the logs.
```terminal:execute
command: tanzu apps workload tail order-service --since 1h
clear: true
```

After the new version of the order service is deployed we can see the TAP has bound our services to the app by checking the environment Actuator enpoint for a property source called `kubernetesServiceBindingSpecific`.

```terminal:execute
session: 2
command: watch -n 1 "curl -s https://order-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/actuator/env | jq '.propertySources[] | select(.name == \"kubernetesServiceBindingSpecific\")'"
clear: true
```
