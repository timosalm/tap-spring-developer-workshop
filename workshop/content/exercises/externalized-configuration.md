In cloud-native applications, configuration shouldn't be bundled with code!

In the cloud, you have multiple applications, environments, and service instances â€” so configuration has to be flexible.

[Spring Cloud Config](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/) is designed to ease this burden by providing server-side and client-side support for externalized configuration in a distributed system. 
With the **Spring Cloud Config Server**, you have a central place to manage external properties for applications across all environments by integrating multiple version control systems to keep your config safe.
The Config Server is implemented with Spring Boot, so you can also try it out easily on your local machine or even embed it in another application - however, it runs best as a standalone application.

To deploy it on a container runtime, an official container image is available (`springcloud/configserver`). As it's not mentioned in the documentation anymore, and last time updated years ago, I recommend building your own.

Part of TAP is the commercial **Application Configuration Service for VMware Tanzu** which is based on the OSS Spring Cloud Config Server and provides a Kubernetes-native experience to enable the runtime configuration.

A Git repository as source of the externalized configuration is already created for you.
```dashboard:open-url
url: {{ ENV_GITEA_BASE_URL }}/externalized-configuration/src/{{ session_namespace }}
```

Our commercial product provides a Kubernetes-native experience for the configuration via a `ConfigurationSource` resource.
The only type of backend currently supported is Git. In addition to the URL of your repository with the externalized configuration, `defaultLabel` is also set, which can be a branch name, a tag name, or a specific Git commit hash to provide different configurations for different environments. In our case, it's just a branch for your workshop session.

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
    apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
    kind: ConfigurationSource
    metadata:
      name: config-source
    spec:
      backends:
        - type: git
          uri: {{ ENV_GITEA_BASE_URL }}/externalized-configuration
          defaultLabel: {{ session_namespace }}
  EOF
clear: true
```
As a next step, you have to create a `ConfigurationSlice` that references this configuration source and the related configuration file for the product service.
```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
  apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
  kind: ConfigurationSlice
  metadata:
    name: product-config-slice
  spec:
    configurationSource: config-source
    content:
    - product-service
  EOF
clear: true
```

To consume the externalized configuration generated by the ConfigurationSlice, we'll use a mechanism called **service binding** on which we'll have a closer look in the next section.
After configuring the service binding in the Workload and applying it to the cluster, the externalized configuration will be mounted into the running application container.
```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  serviceClaims:
  - name: config-server
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ResourceClaim
      name: config-server-claim
```

The only thing we have to add to our application source code, is the `spring.config.import` configuration targeting the mounted configuration.
```editor:insert-value-into-yaml
file: ~/product-service/src/main/resources/application.yaml
path: spring
value:
  config.import: "optional:configtree:${SERVICE_BINDING_ROOT}/config-server/"
```
Removing the `optional:` prefix will cause the application to fail if it is unable to find the directory.

To apply the changes, we have to update the Workload in the environment and commit the updated source code.
```terminal:execute
command: |
  cd product-service && git add . && git commit -m "Add external configuration support" && git push
  cd ..
clear: true
```
```terminal:execute
command: tanzu apps workload apply -f product-service/config/workload.yaml -y
clear: true
```
Lets tail the logs again to watch as the new version of our application is built and deployed.

```terminal:execute
session: 2
command: |
  tanzu apps workload tail product-service --since 1h
```

As soon as our outdated application and service binding is applied ...
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/supply-chain/host/{{ session_namespace }}/product-service
```
... we should be able to see a longer product list configured via our Git repository.
```terminal:execute
command: curl -s http://product-service.{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/products | jq .
clear: true
```

![Updated architecture with Configuration Service](../images/microservice-architecture-config.png)
