```terminal:execute
command: |
  (cd ~/samples/externalized-configuration && git init -b main && git remote add origin $GIT_PROTOCOL://$GIT_HOST/externalized-configuration.git && git add . && git commit -m "Initial implementation" && git push -u origin main)
autostart: true
hidden: true
```

In cloud-native applications, it is good practice to remove the application's configuration from the code and instead manage all configuration externally.

In the cloud, you have multiple applications, environments, and service instances â€” so configuration has to be flexible.

[Spring Cloud Config](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/) is designed to ease this burden by providing server-side and client-side support for externalized configuration in a distributed system. 
With the **Spring Cloud Config Server**, you have a central place to manage external properties for applications across all environments by integrating multiple version control systems to keep your config safe.
The Config Server is implemented with Spring Boot, so you can also try it out easily on your local machine or even embed it in another application - however, it runs best as a standalone application.

TAP provides the **Application Configuration Service for VMware Tanzu** which is a commercial offering based on the OSS Spring Cloud Config Server and provides a Kubernetes-native experience to enable the runtime configuration.

To use the Application Configuration Service we first need a Git repository to store our configuration in.  For this workshop, we have already set-up a Git repo for you.

```dashboard:open-url
url: {{ git_protocol }}://{{ git_username }}:{{ git_password }}@{{ git_host }}/externalized-configuration
```

If you are familiar with Spring Cloud Config, certain concepts of the Application Configuration Service will feel very familiar while others are a bit different.

For example, you can configure the Application Configuration Service to use a `defaultLabel` which can be a branch name, a tag name, or a specific Git commit hash to provide different configurations for different environments.  This is very similar to Spring Cloud Config.  In our case, it's just a branch for your workshop session.

Our commercial product provides a Kubernetes-native experience for the configuration via a `ConfigurationSource` resource.

Let's create the `ConfigurationSource` with our `defaultLabel` pointing at our Git repo.

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
    apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
    kind: ConfigurationSource
    metadata:
      name: config-source
    spec:
      backends:
        - type: git
          uri: {{ git_protocol }}://{{ git_host }}/externalized-configuration
          defaultLabel: main
  EOF
clear: true
```

As a next step, you have to create a `ConfigurationSlice` that references this configuration source (`spec.configurationSource` in the below YAML) and the related configuration file(s) for the product-service (`spec.content` in the below YAML).
In this case, we just have a single file (`product-service.yaml`) we would like to use to configure the product-service.

```dashboard:open-url
url: {{ git_protocol }}://{{ git_host }}/externalized-configuration/src/{{ session_namespace }}/product-service.yaml
```

To create the `ConfigurationSlice` execute the following command.

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
  apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
  kind: ConfigurationSlice
  metadata:
    name: product-config-slice
  spec:
    configurationSource: config-source
    content:
    - product-service
  EOF
clear: true
```

To consume the externalized configuration generated by the ConfigurationSlice, we'll use a mechanism called **service binding**.  We will explore service bindings more in the next section, but for now, all you need to know
is that when we create this service binding TAP will mount the files from the `ConfigurationSlice` inside the container at `SERVICE_BINDING_ROOT/<name of service claim>`.  `SERVICE_BINDING_ROOT` is the name of an environment variable that will be set within the container by TAP.

```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  serviceClaims:
  - name: config-server
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ResourceClaim
      name: product-config-server-claim
```

The ResourceClaim pointed to in the service claim above was already created for you when this workshop was initialized.

{% raw %}
```
apiVersion: services.apps.tanzu.vmware.com/v1alpha1
kind: ResourceClaim
metadata:
  name: product-config-server-claim
spec:
  ref:
    apiVersion: config.apps.tanzu.vmware.com/v1alpha4
    kind: ConfigurationSlice
    name: product-config-slice
```
{% endraw %}

TAP mounts each property within the configuration file(s) as a file, with the contents being 
the value of the configuration property.  Spring Boot can load all these "file values" pairs in a given directory using the `configtree` prefix in `spring.config.import`.  Let's add a `SPRING_CONFIG_IMPORT` environment property to the product-service's `workload.yaml`.

```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  env:
  - name: SPRING_CONFIG_IMPORT
    value: "optional:configtree:${SERVICE_BINDING_ROOT}/config-server/"   
```

To apply the changes, update the Workload for the product-service deployed to TAP
```terminal:execute
command: tanzu apps workload apply -f product-service/config/workload.yaml -y
clear: true
```
Let's `watch` the updated version of our product-service rolled out by TAP.

```terminal:execute
session: 2
command: |
  tanzu apps workload tail product-service --since 1h
```

We can also issue a watch command to `curl` `/api/v1/products`.  Initially, the JSON returned will be the products from our `application.yaml` file as before.  However, once the 
new version of our application is deployed the products returned will come from `product-service.yaml` from our `external-configuration` Git repo.
```terminal:execute
command: watch -n 1 'curl -s https://product-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/products | jq .'
clear: true
```

The result of the `curl` command should eventually look like this.

```
[
  {
    "id": 1,
    "name": "VMware Tanzu Application Platform"
  },
  {
    "id": 2,
    "name": "VMware Spring Runtime"
  },
  {
    "id": 3,
    "name": "VMware Tanzu for Kubernetes Operations"
  },
  {
    "id": 4,
    "name": "VMware Tanzu Application Service"
  },
  {
    "id": 5,
    "name": "VMware Data Services"
  },
  {
    "id": 6,
    "name": "VMware Application Catalog"
  }
]
```

Our architecture should now look like this

![Updated architecture with Configuration Service](../images/microservice-architecture-config.png)

Let's interrupt our terminal sessions before moving on.

```terminal:interrupt-all
```
