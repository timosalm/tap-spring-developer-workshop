```terminal:interrupt
autostart: true
hidden: true
cascade: true
```
```terminal:execute
command: |
  (cd ~/samples/externalized-configuration && [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ] && git init -b main && git remote add origin $GIT_PROTOCOL://$GIT_HOST/externalized-configuration.git && git add . && git commit -m "Initial implementation" && git push -u origin main)
  clear
hidden: true
cascade: true
```
```dashboard:open-dashboard
name: The Twelve Factors
hidden: true
```

In cloud-native applications, it is good practice to remove the application's configuration from the code and instead manage all configuration externally.

In the cloud, you have multiple applications, environments, and service instances â€” so configuration has to be flexible.

[Spring Cloud Config](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/) is designed to ease this burden by providing server-side and client-side support for externalized configuration in a distributed system. 
With the **Spring Cloud Config Server**, you have a central place to manage external properties for applications across all environments by integrating multiple version control systems to keep your config safe.
The Config Server is implemented with Spring Boot, so you can also try it out easily on your local machine or even embed it in another application - however, it runs best as a standalone application.

TAP provides the **Application Configuration Service for VMware Tanzu** which is a commercial offering based on the OSS Spring Cloud Config Server and provides a Kubernetes-native experience to enable the runtime configuration.

To use the Application Configuration Service we first need a Git repository to store our configuration in.  For this workshop, we have already set-up a Git repo for you.

```dashboard:reload-dashboard
name: GIT UI
url: {{ ingress_protocol }}://git-ui-{{ session_name }}.{{ ingress_domain }}?p=externalized-configuration.git;a=tree
```

If you are familiar with Spring Cloud Config, certain concepts of the Application Configuration Service will feel very familiar while others are a bit different.

For example, you can configure the Application Configuration Service to use a `defaultLabel` which can be a branch name, a tag name, or a specific Git commit hash to provide different configurations for different environments.  This is very similar to Spring Cloud Config.  In our case, it's just a branch for your workshop session.

Our commercial product provides a Kubernetes-native experience for the configuration via a `ConfigurationSource` resource.

Let's create the `ConfigurationSource` resource configuration pointing at our Git repo.
```editor:append-lines-to-file
file: ~/config/config-server/configuration-source.yaml
description: Create ConfigurationSource
text: |
  apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
  kind: ConfigurationSource
  metadata:
    name: config-source
  spec:
    backends:
      - type: git
        uri: {{ git_protocol }}://{{ git_host }}/externalized-configuration.git
        defaultLabel: main
        secretRef:
          name: git-https
          namespace: {{ session_namespace }}
```

As a next step, you have to create a `ConfigurationSlice` that references this configuration source (`spec.configurationSource` in the below YAML) and the related configuration file(s) for the product-service (`spec.content` in the below YAML).
In this case, we just have a single file (`product-service.yaml`) we would like to use to configure the product-service.

```dashboard:reload-dashboard
name: GIT UI
url: {{ ingress_protocol }}://git-ui-{{ session_name }}.{{ ingress_domain }}?p=externalized-configuration.git;a=blob;f=product-service.yaml
```

To create the `ConfigurationSlice` resource configuration execute the following command.

```editor:append-lines-to-file
file: ~/config/config-server/configuration-slice.yaml
description: Create ConfigurationSlice
text: |
  apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
  kind: ConfigurationSlice
  metadata:
    name: product-config-slice
  spec:
    interval: 30s
    configurationSource: config-source
    content:
    - product-service
```
Let's apply everything to the cluster.
```terminal:execute
command: kubectl apply -f ~/config/config-server/
clear: true
```

To consume the externalized configuration generated by the ConfigurationSlice, we'll use a mechanism called **service binding**.  We will explore service bindings more in the next section, but for now, all you need to know
is that when we create this service binding TAP will mount the files from the `ConfigurationSlice` inside the container at `SERVICE_BINDING_ROOT/<name of service claim>`.  `SERVICE_BINDING_ROOT` is the name of an environment variable that will be set within the container by TAP.

```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  serviceClaims:
  - name: config-server
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ResourceClaim
      name: product-config-server-claim
```

The ResourceClaim pointed to in the service claim above was already created for you when this workshop was initialized.

{% raw %}
```
apiVersion: services.apps.tanzu.vmware.com/v1alpha1
kind: ResourceClaim
metadata:
  name: product-config-server-claim
spec:
  ref:
    apiVersion: config.apps.tanzu.vmware.com/v1alpha4
    kind: ConfigurationSlice
    name: product-config-slice
```
{% endraw %}

TAP mounts each property within the configuration file(s) as a file, with the contents being 
the value of the configuration property.  Spring Boot can load all these "file values" pairs in a given directory using the `configtree` prefix in `spring.config.import`.  Let's add a `SPRING_CONFIG_IMPORT` environment property to the product-service's `workload.yaml`.

```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  env:
  - name: SPRING_CONFIG_IMPORT
    value: "optional:configtree:${SERVICE_BINDING_ROOT}/config-server/"   
```

To apply the changes, update the Workload for the product-service deployed to TAP
```terminal:execute
command: tanzu apps workload apply -f product-service/config/workload.yaml -y
clear: true
```
Let's `watch` the updated version of our product-service rolled out by TAP.

```terminal:execute
session: 2
command: |
  tanzu apps workload tail product-service --since 1h
```

We can also issue a watch command to `curl` `/api/v1/products`.  Initially, the JSON returned will be the products from our `application.yaml` file as before.  However, once the 
new version of our application is deployed the products returned will come from `product-service.yaml` from our `external-configuration` Git repo.
```terminal:execute
command: watch -n 1 'curl -s https://product-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/products | jq .'
clear: true
```

The result of the `curl` command should eventually look like this.

```
[
  {
    "id": 1,
    "name": "VMware Tanzu Application Platform"
  },
  {
    "id": 2,
    "name": "VMware Spring Runtime"
  },
  {
    "id": 3,
    "name": "VMware Tanzu for Kubernetes Operations"
  },
  ...
]
```

Our architecture should now look like this

![Updated architecture with Configuration Service](../images/microservice-architecture-config.png)

Let's interrupt our terminal sessions before moving on.

```terminal:interrupt-all
```
