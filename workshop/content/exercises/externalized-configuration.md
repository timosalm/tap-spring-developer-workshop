In cloud-native applications, it is good practice to remove the application's configuration from the code and instead manage all configuration externally.

In the cloud, you have multiple applications, environments, and service instances â€” so configuration has to be flexible.

[Spring Cloud Config](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/) is designed to ease this burden by providing server-side and client-side support for externalized configuration in a distributed system. 
With the **Spring Cloud Config Server**, you have a central place to manage external properties for applications across all environments by integrating multiple version control systems to keep your config safe.
The Config Server is implemented with Spring Boot, so you can also try it out easily on your local machine or even embed it in another application - however, it runs best as a standalone application.

TAP provides the **Application Configuration Service for VMware Tanzu** which is a commercial offering based on the OSS Spring Cloud Config Server and provides a Kubernetes-native experience to enable the runtime configuration.

To use the Application Configuration Service we first need a Git repository to store our configuration in.  For this workshop we have already setup a Git repo for you.

```dashboard:open-url
url: {{ ENV_GITEA_BASE_URL }}/externalized-configuration/src/{{ session_namespace }}
```

If you are familiar with Spring Cloud Config certain concepts of the Application Configuration Service will feel very familiar while others are a bit different.

For example, you can configure the Application Configuration Service to use a `defaultLabel` which can be a branch name, a tag name, or a specific Git commit hash to provide different configurations for different environments.  This is very similar to Spring Cloud Config.  In our case, it's just a branch for your workshop session.

on the other hand to configure the Application Configuration Service to point to our Git repo we need to create a Kubernetes resource called a `ConfigurationSource`.
Our commercial product provides a Kubernetes-native experience for the configuration via a `ConfigurationSource` resource.

Lets create the `ConfigurationSource` with our `defaultLabel` pointing at out Git repo.

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
    apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
    kind: ConfigurationSource
    metadata:
      name: config-source
    spec:
      backends:
        - type: git
          uri: {{ ENV_GITEA_BASE_URL }}/externalized-configuration
          defaultLabel: {{ session_namespace }}
  EOF
clear: true
```

As a next step, you have to create a `ConfigurationSlice` that references this configuration source (`spec.configurationSource` in the below YAML) and the related configuration file(s) for the product-service (`spec.content` in the below YAML).
In this case we just have a single file (`product-service.yaml`) we would like to use to configure the product-service.

```dashboard:open-url
url: {{ ENV_GITEA_BASE_URL }}/externalized-configuration/src/{{ session_namespace }}/product-service.yaml
```

To create the `ConfigurationSlice` exercute the following command.

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
  apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
  kind: ConfigurationSlice
  metadata:
    name: product-config-slice
  spec:
    configurationSource: config-source
    content:
    - product-service
  EOF
clear: true
```

To consume the externalized configuration generated by the ConfigurationSlice, we'll use a mechanism called **service binding**.  We will explore service bindings more in the next section, but for now all you need to know
is that when we create this service binding TAP will mount the files from the `ConfigurationSlice` inside the container at `SERVICE_BINDING_ROOT/<name of service claim>`.  `SERVICE_BINDING_ROOT` is the name of an environment
variable that will be set within the container by TAP.

```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  serviceClaims:
  - name: config-server
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ResourceClaim
      name: product-config-server-claim
```

TAP mounts each property within the configuration file(s) as a file with the contents being 
the value of the configuration property.  Spring Boot can load all these "file values" pairs in a given directory using the `configtree` prefix in `spring.config.import`.  Lets add a `spring.config.import` statement to the product-service's
`application.yaml`.

```editor:insert-value-into-yaml
file: ~/product-service/src/main/resources/application.yaml
path: spring
value:
  config.import: "optional:configtree:${SERVICE_BINDING_ROOT}/config-server/"
```

To apply the changes, commit the updated source code and update the Workload for the product-service deployed to TAP
```terminal:execute
command: |
  cd product-service && git add . && git commit -m "Add external configuration support" && git push
  cd ..
clear: true
```
```terminal:execute
command: tanzu apps workload apply -f product-service/config/workload.yaml -y
clear: true
```
Lets `watch` the updated version of our product-service rolled out by TAP.

```terminal:execute
session: 2
command: |
  watch -n 1 tanzu apps workload get product-service
```

As soon as our updated application is deployed we should be able to see a longer product list configured via our Git repository.
```terminal:execute
command: curl -s https://product-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/products | jq .
clear: true
```

The result of the `curl` command should now show the products listed in `product-service.yaml` from our `external-configuration` Git repo.

```
[
  {
    "id": 1,
    "name": "VMware Tanzu Application Platform"
  },
  {
    "id": 2,
    "name": "VMware Spring Runtime"
  },
  {
    "id": 3,
    "name": "VMware Tanzu for Kubernetes Operations"
  },
  {
    "id": 4,
    "name": "VMware Tanzu Application Service"
  },
  {
    "id": 5,
    "name": "VMware Data Services"
  },
  {
    "id": 6,
    "name": "VMware Application Catalog"
  }
]
```

![Updated architecture with Configuration Service](../images/microservice-architecture-config.png)
