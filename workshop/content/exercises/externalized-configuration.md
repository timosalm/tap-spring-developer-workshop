In cloud-native applications, it is good practice to remove the application's configuration from the code and instead manage all configuration externally.

In the cloud, you have multiple applications, environments, and service instances â€” so configuration has to be flexible.

[Spring Cloud Config](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/) is designed to ease this burden by providing server-side and client-side support for externalized configuration in a distributed system. 
With the **Spring Cloud Config Server**, you have a central place to manage external properties for applications across all environments by integrating multiple version control systems to keep your config safe.
The Config Server is implemented with Spring Boot, so you can also try it out easily on your local machine or even embed it in another application - however, it runs best as a standalone application.

TAP provides the **Application Configuration Service for VMware Tanzu** which is a commercial offering based on the OSS Spring Cloud Config Server and provides a Kubernetes-native experience to enable the runtime configuration.

To use the Application Configuration Service we first need a Git repository to store our configuration in.  For this workshop we have already setup a Git repo for you.

```dashboard:open-url
url: {{ ENV_GITEA_BASE_URL }}/externalized-configuration/src/{{ session_namespace }}
```

If you are familiar with Spring Cloud Config certain concepts of the Application Configuration Service will feel very familiar while others are a bit different.

For example, you can configure the Application Configuration Service to use a `defaultLabel` which can be a branch name, a tag name, or a specific Git commit hash to provide different configurations for different environments.  This is very similar to Spring Cloud Config.  In our case, it's just a branch for your workshop session.

on the other hand to configure the Application Configuration Service to point to our Git repo we need to create a Kubernetes resource called a `ConfigurationSource`.
Our commercial product provides a Kubernetes-native experience for the configuration via a `ConfigurationSource` resource.

Lets create the `ConfigurationSource` with our `defaultLabel` pointing at out Git repo.

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
    apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
    kind: ConfigurationSource
    metadata:
      name: config-source
    spec:
      backends:
        - type: git
          uri: {{ ENV_GITEA_BASE_URL }}/externalized-configuration
          defaultLabel: {{ session_namespace }}
  EOF
clear: true
```

As a next step, you have to create a `ConfigurationSlice` that references this configuration source and the related configuration file(s) for the product-service.
In this case we just have a single file we would like to use to configure the product-service.

```dashboard:open-url
url: {{ ENV_GITEA_BASE_URL }}/externalized-configuration/src/{{ session_namespace }}/product-service.yaml
```

To create the `ConfigurationSlice` exercute the following command.

```terminal:execute
command: |
  cat <<EOF | kubectl apply -f -
  apiVersion: "config.apps.tanzu.vmware.com/v1alpha4"
  kind: ConfigurationSlice
  metadata:
    name: product-config-slice
  spec:
    configurationSource: config-source
    content:
    - product-service
  EOF
clear: true
```

To consume the externalized configuration generated by the ConfigurationSlice, we'll use a mechanism called **service binding** on which we'll have a closer look in the next section.
After configuring the service binding in the Workload and applying it to the cluster, the externalized configuration will be mounted into the running application container.
```editor:insert-value-into-yaml
file: ~/product-service/config/workload.yaml
path: spec
value:
  serviceClaims:
  - name: config-server
    ref:
      apiVersion: services.apps.tanzu.vmware.com/v1alpha1
      kind: ResourceClaim
      name: product-config-server-claim
```

The only thing we have to add to our application source code, is the `spring.config.import` configuration targeting the mounted configuration.
```editor:insert-value-into-yaml
file: ~/product-service/src/main/resources/application.yaml
path: spring
value:
  config.import: "optional:configtree:${SERVICE_BINDING_ROOT}/config-server/"
```
Removing the `optional:` prefix will cause the application to fail if it is unable to find the directory.

To apply the changes, we have to update the Workload in the environment and commit the updated source code.
```terminal:execute
command: |
  cd product-service && git add . && git commit -m "Add external configuration support" && git push
  cd ..
clear: true
```
```terminal:execute
command: tanzu apps workload apply -f product-service/config/workload.yaml -y
clear: true
```
Lets tail the logs again to watch as the new version of our application is built and deployed.

```terminal:execute
session: 2
command: |
  tanzu apps workload tail product-service --since 1h
```

As soon as our outdated application and service binding is applied ...
```dashboard:open-url
url: https://tap-gui.{{ ENV_TAP_INGRESS }}/supply-chain/host/{{ session_namespace }}/product-service
```
... we should be able to see a longer product list configured via our Git repository.
```terminal:execute
command: curl -s https://product-service-{{ session_namespace }}.{{ ENV_TAP_INGRESS }}/api/v1/products | jq .
clear: true
```

![Updated architecture with Configuration Service](../images/microservice-architecture-config.png)
